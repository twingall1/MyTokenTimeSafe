<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ðŸ”’ Time Lock Safe</title>
  <style>
    body {
      font-family: Arial, system-ui;
      max-width: 900px;
      margin: 2rem auto;
      color: #222;
      background: #f7f8fb;
    }
    .card {
      background: white;
      padding: 1rem;
      margin-bottom: 1rem;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    }
    input, button, select {
      font-size: 1rem;
      padding: 0.5rem;
      margin: 0.25rem 0;
      width: 100%;
      box-sizing: border-box;
    }
    .row { display: flex; gap: 0.5rem; }
    .col { flex: 1; }
    .muted { color: #666; font-size: 0.9rem; }
    .small { font-size: 0.85rem; color: #333; }
    .green { color: #0a8; }
    .red { color: #d00; }
    .lock-item {
      border-left: 4px solid #eee;
      padding-left: 0.75rem;
      margin-bottom: 0.75rem;
    }
  </style>

  <!-- âœ… Load ethers.js first -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <h1>ðŸ”’ Time Lock Safe</h1>
  <p class="muted">
    Lock any PRC-20 token until an exact future date/time (UTC).<br>
    Only you can withdraw, and only after the unlock time.
  </p>

  <div class="card">
    <div id="walletArea">
      <button id="connectBtn">Connect Wallet</button>
      <div id="connected" style="display:none;">
        <div class="small">Connected: <span id="addr"></span></div>
        <div class="small muted">Network: <span id="network"></span></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Create a new lock</h3>
    <label>Token contract address (PRC-20 / ERC-20)</label>
    <input id="tokenAddress" placeholder="0x..." />

    <label>Amount (human units, e.g. 100.0)</label>
    <input id="amount" placeholder="100.0" />

    <label>Unlock date &amp; time (your local time)</label>
    <input id="when" type="datetime-local" />

    <button id="approveAndLockBtn">Approve &amp; Lock</button>
    <div id="txStatus" class="muted"></div>
    <div class="muted small">
      Tip: Test first with a tiny amount and a short wait (like +2 minutes).
    </div>
  </div>

  <div class="card">
    <h3>Your locks</h3>
    <div id="locksList" class="muted">Connect wallet to load locks.</div>
  </div>

  <script>
  const DEFAULT_CONTRACT_ADDRESS = "0x64b280cEa1a08c6cea1EB5b441b2D81d2EF996BE";

  const ABI = [
    "function lockTokens(address token, uint256 amount, uint256 unlockTime) external",
    "function withdraw(uint256 lockId) external",
    "function getLockCount(address depositor) external view returns (uint256)",
    "function getLock(address depositor, uint256 index) external view returns (address token, uint256 amount, uint256 unlockTime, bool withdrawn)",
    "event Locked(address indexed depositor, uint256 indexed lockId, address indexed token, uint256 amount, uint256 unlockTime)",
    "event Withdrawn(address indexed depositor, uint256 indexed lockId, address indexed token, uint256 amount)"
  ];

  let provider, signer, contract, userAddress;

  async function init() {
    if (typeof window.ethereum === "undefined") {
      document.getElementById("walletArea").innerHTML = `
        <b>No wallet detected.</b><br/>
        Open this page in a browser with MetaMask / OKX wallet installed
        or in the in-app browser of your wallet.
      `;
      return;
    }

    // âœ… Explicitly set PulseChain mainnet to prevent ENS warning
    provider = new ethers.providers.Web3Provider(window.ethereum, { name: "pulsechain", chainId: 369 });
    document.getElementById("connectBtn").addEventListener("click", connectWallet);
    document.getElementById("approveAndLockBtn").addEventListener("click", approveAndLock);
  }

  async function connectWallet() {
    try {
      await window.ethereum.request({ method: "eth_requestAccounts" });
      provider = new ethers.providers.Web3Provider(window.ethereum, { name: "pulsechain", chainId: 369 });
      signer = provider.getSigner();
      userAddress = await signer.getAddress();

      document.getElementById("addr").textContent = userAddress;
      document.getElementById("connectBtn").style.display = "none";
      document.getElementById("connected").style.display = "block";

      const network = await provider.getNetwork();
      document.getElementById("network").textContent = `PulseChain (chainId ${network.chainId})`;

      contract = new ethers.Contract(DEFAULT_CONTRACT_ADDRESS, ABI, signer);
      await loadLocks();
    } catch (err) {
      console.error(err);
      alert("Could not connect wallet: " + (err.message || err));
    }
  }

  async function toRawAmount(tokenAddr, humanAmountStr) {
    const token = new ethers.Contract(tokenAddr, ["function decimals() view returns (uint8)"], provider);
    let decimals = 18;
    try { decimals = await token.decimals(); } catch (e) {}
    return ethers.utils.parseUnits(humanAmountStr, decimals);
  }

  async function approveAndLock() {
    if (!signer || !contract || !userAddress) return alert("Connect wallet first.");
    const tokenAddr = document.getElementById("tokenAddress").value.trim();
    const amountStr = document.getElementById("amount").value.trim();
    const whenLocal = document.getElementById("when").value;
    if (!ethers.utils.isAddress(tokenAddr)) return alert("Invalid token address");
    if (!amountStr || isNaN(Number(amountStr))) return alert("Invalid amount");
    if (!whenLocal) return alert("Select unlock date/time");

    const whenDate = new Date(whenLocal);
    const unlockTs = Math.floor(whenDate.getTime() / 1000);
    if (unlockTs <= Math.floor(Date.now() / 1000)) return alert("Unlock time must be in the future.");

    const statusEl = document.getElementById("txStatus");
    statusEl.textContent = "Preparing approval & lock...";
    try {
      const raw = await toRawAmount(tokenAddr, amountStr);
      const erc20 = new ethers.Contract(tokenAddr, ["function approve(address spender, uint256 amount) public returns (bool)"], signer);
      const approveTx = await erc20.approve(contract.address, raw);
      statusEl.textContent = "Waiting for approval confirmation...";
      await approveTx.wait();

      // Gas limit override (helps with certain tokens)
      const lockTx = await contract.lockTokens(tokenAddr, raw, unlockTs, { gasLimit: 300000 });
      statusEl.textContent = "Lock transaction sent, waiting for confirmation...";
      await lockTx.wait();

      statusEl.textContent = "âœ… Lock created.";
      await loadLocks();
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Error: " + (err.message || err);
      alert("Error: " + (err.message || err));
    }
  }

  async function loadLocks() {
    const listEl = document.getElementById("locksList");
    listEl.textContent = "Loading locks...";
    try {
      const count = await contract.getLockCount(userAddress);
      const n = count.toNumber ? count.toNumber() : Number(count);
      if (n === 0) {
        listEl.innerHTML = "<div class='muted'>No locks found.</div>";
        return;
      }
      const items = [];
      for (let i=0; i<n; i++){
        const res = await contract.getLock(userAddress, i);
        items.push({ index:i, token:res[0], amount:res[1].toString(), unlockTime:Number(res[2]), withdrawn:res[3] });
      }
      renderLocks(items);
    } catch (e) {
      console.error(e);
      listEl.textContent = "Error loading locks: " + (e.message || e);
    }
  }

  function renderLocks(items) {
    const out = document.getElementById("locksList");
    out.innerHTML = "";
    items.forEach(item=>{
      const wrap = document.createElement("div");
      wrap.className = "lock-item card";
      wrap.innerHTML = `
        <b>Lock #${item.index}</b><br/>
        <div class='small muted'>Token: ${item.token}</div>
        <div class='small muted'>Amount (raw units): ${item.amount}</div>
        <div>Unlocks (UTC): ${new Date(item.unlockTime*1000).toUTCString()}</div>
      `;
      const status = document.createElement("div");
      wrap.appendChild(status);
      const btn = document.createElement("button");
      btn.textContent = "Withdraw";
      btn.disabled = true;
      wrap.appendChild(btn);
      const countdown = document.createElement("div");
      countdown.className = "small";
      wrap.appendChild(countdown);
      out.appendChild(wrap);

      btn.addEventListener("click", async ()=>{
        btn.disabled = true;
        status.textContent = "Withdrawing...";
        try {
          const tx = await contract.withdraw(item.index);
          status.textContent = "Tx sent â€” waiting...";
          await tx.wait();
          status.textContent = "âœ… Withdrawn.";
          loadLocks();
        } catch(err){
          console.error(err);
          status.textContent = "Error: " + (err.message||err);
          btn.disabled = false;
        }
      });

      const timer = setInterval(()=>{
        const now = Math.floor(Date.now()/1000);
        if(item.withdrawn){
          countdown.innerHTML = "<span class='green'>Already withdrawn</span>";
          btn.disabled = true; clearInterval(timer); return;
        }
        if(now>=item.unlockTime){
          countdown.innerHTML = "<span class='green'>Ready to withdraw</span>";
          btn.disabled = false; return;
        }
        const sec=item.unlockTime-now;
        const d=Math.floor(sec/86400),h=Math.floor((sec%86400)/3600),m=Math.floor((sec%3600)/60),s=sec%60;
        countdown.textContent=`Time remaining: ${d}d ${h}h ${m}m ${s}s`;
      },1000);
    });
  }

  window.addEventListener("load", init);
  </script>
</body>
</html>
